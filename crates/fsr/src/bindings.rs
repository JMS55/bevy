/* automatically generated by rust-bindgen 0.69.4 */

pub const FFX_MAX_NUM_SRVS: u32 = 16;
pub const FFX_MAX_NUM_UAVS: u32 = 8;
pub const FFX_MAX_NUM_CONST_BUFFERS: u32 = 2;
pub const FFX_MAX_CONST_SIZE: u32 = 64;
pub const FFX_UNSPECIFIED_VERSION: u32 = 4294946048;
pub const FFX_MAXIMUM_PATH: u32 = 260;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_NULL: u32 = 0;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_COLOR: u32 = 1;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_MOTION_VECTORS: u32 = 2;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_DEPTH: u32 = 3;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_EXPOSURE: u32 = 4;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_REACTIVE_MASK: u32 = 5;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INPUT_TRANSPARENCY_AND_COMPOSITION_MASK: u32 = 6;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_RECONSTRUCTED_PREVIOUS_NEAREST_DEPTH: u32 = 7;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_MOTION_VECTORS: u32 = 8;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_DEPTH: u32 = 9;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR: u32 = 10;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS: u32 = 11;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_DEPTH_CLIP: u32 = 12;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_PREPARED_INPUT_COLOR: u32 = 13;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LUMA_HISTORY: u32 = 14;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_DEBUG_OUTPUT: u32 = 15;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LANCZOS_LUT: u32 = 16;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_SPD_ATOMIC_COUNT: u32 = 17;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_UPSCALED_OUTPUT: u32 = 18;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_RCAS_INPUT: u32 = 19;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS_1: u32 = 20;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_LOCK_STATUS_2: u32 = 21;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_1: u32 = 22;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_UPSCALED_COLOR_2: u32 = 23;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_REACTIVITY: u32 = 24;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_TRANSPARENCY_AND_COMPOSITION: u32 = 25;
pub const FFX_FSR2_RESOURCE_IDENTITIER_UPSAMPLE_MAXIMUM_BIAS_LUT: u32 = 26;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_DILATED_REACTIVE_MASKS: u32 = 27;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE: u32 = 28;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_0: u32 = 28;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_1: u32 = 29;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_2: u32 = 30;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_3: u32 = 31;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_4: u32 = 32;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_5: u32 = 33;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_6: u32 = 34;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_7: u32 = 35;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_8: u32 = 36;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_9: u32 = 37;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_10: u32 = 38;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_11: u32 = 39;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_12: u32 = 40;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_INTERNAL_DEFAULT_EXPOSURE: u32 = 41;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_EXPOSURE: u32 = 42;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_AUTO_EXPOSURE_MIPMAP_SHADING_CHANGE: u32 = 32;
pub const FFX_FSR2_SHADING_CHANGE_MIP_LEVEL: u32 = 4;
pub const FFX_FSR2_RESOURCE_IDENTIFIER_COUNT: u32 = 43;
pub const FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_FSR2: u32 = 0;
pub const FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_SPD: u32 = 1;
pub const FFX_FSR2_CONSTANTBUFFER_IDENTIFIER_RCAS: u32 = 2;
pub const FFX_FSR2_AUTOREACTIVEFLAGS_APPLY_TONEMAP: u32 = 1;
pub const FFX_FSR2_AUTOREACTIVEFLAGS_APPLY_INVERSETONEMAP: u32 = 2;
pub const FFX_FSR2_AUTOREACTIVEFLAGS_APPLY_THRESHOLD: u32 = 4;
pub const FFX_FSR2_AUTOREACTIVEFLAGS_USE_COMPONENTS_MAX: u32 = 8;
pub const FFX_FSR2_VERSION_MAJOR: u32 = 2;
pub const FFX_FSR2_VERSION_MINOR: u32 = 1;
pub const FFX_FSR2_VERSION_PATCH: u32 = 2;
pub const FFX_FSR2_CONTEXT_SIZE: u32 = 16536;
#[doc = "< Unknown format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_UNKNOWN: FfxSurfaceFormat = 0;
#[doc = "< 32 bit per channel, 4 channel typeless format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32G32B32A32_TYPELESS: FfxSurfaceFormat = 1;
#[doc = "< 32 bit per channel, 4 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32G32B32A32_FLOAT: FfxSurfaceFormat = 2;
#[doc = "< 16 bit per channel, 4 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16G16B16A16_FLOAT: FfxSurfaceFormat = 3;
#[doc = "< 16 bit per channel, 4 channel unsigned normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16G16B16A16_UNORM: FfxSurfaceFormat = 4;
#[doc = "< 32 bit per channel, 2 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32G32_FLOAT: FfxSurfaceFormat = 5;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32_UINT: FfxSurfaceFormat = 6;
#[doc = "<  8 bit per channel, 4 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R8G8B8A8_TYPELESS: FfxSurfaceFormat = 7;
#[doc = "<  8 bit per channel, 4 channel unsigned normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R8G8B8A8_UNORM: FfxSurfaceFormat = 8;
#[doc = "< 32 bit 3 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R11G11B10_FLOAT: FfxSurfaceFormat = 9;
#[doc = "< 16 bit per channel, 2 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16G16_FLOAT: FfxSurfaceFormat = 10;
#[doc = "< 16 bit per channel, 2 channel unsigned int format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16G16_UINT: FfxSurfaceFormat = 11;
#[doc = "< 16 bit per channel, 1 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16_FLOAT: FfxSurfaceFormat = 12;
#[doc = "< 16 bit per channel, 1 channel unsigned int format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16_UINT: FfxSurfaceFormat = 13;
#[doc = "< 16 bit per channel, 1 channel unsigned normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16_UNORM: FfxSurfaceFormat = 14;
#[doc = "< 16 bit per channel, 1 channel signed normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R16_SNORM: FfxSurfaceFormat = 15;
#[doc = "<  8 bit per channel, 1 channel unsigned normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R8_UNORM: FfxSurfaceFormat = 16;
#[doc = "<  8 bit per channel, 2 channel unsigned normalized format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R8G8_UNORM: FfxSurfaceFormat = 17;
#[doc = "< 32 bit per channel, 1 channel float format"]
pub const FfxSurfaceFormat_FFX_SURFACE_FORMAT_R32_FLOAT: FfxSurfaceFormat = 18;
#[doc = " An enumeration of surface formats."]
pub type FfxSurfaceFormat = ::std::os::raw::c_uint;
#[doc = "< No usage flags indicate a resource is read only."]
pub const FfxResourceUsage_FFX_RESOURCE_USAGE_READ_ONLY: FfxResourceUsage = 0;
#[doc = "< Indicates a resource will be used as render target."]
pub const FfxResourceUsage_FFX_RESOURCE_USAGE_RENDERTARGET: FfxResourceUsage = 1;
#[doc = "< Indicates a resource will be used as UAV."]
pub const FfxResourceUsage_FFX_RESOURCE_USAGE_UAV: FfxResourceUsage = 2;
#[doc = " An enumeration of resource usage."]
pub type FfxResourceUsage = ::std::os::raw::c_uint;
#[doc = "< Indicates a resource is in the state to be used as UAV."]
pub const FfxResourceStates_FFX_RESOURCE_STATE_UNORDERED_ACCESS: FfxResourceStates = 1;
#[doc = "< Indicates a resource is in the state to be read by compute shaders."]
pub const FfxResourceStates_FFX_RESOURCE_STATE_COMPUTE_READ: FfxResourceStates = 2;
#[doc = "< Indicates a resource is in the state to be used as source in a copy command."]
pub const FfxResourceStates_FFX_RESOURCE_STATE_COPY_SRC: FfxResourceStates = 4;
#[doc = "< Indicates a resource is in the state to be used as destination in a copy command."]
pub const FfxResourceStates_FFX_RESOURCE_STATE_COPY_DEST: FfxResourceStates = 8;
#[doc = "< Indicates a resource is in generic (slow) read state."]
pub const FfxResourceStates_FFX_RESOURCE_STATE_GENERIC_READ: FfxResourceStates = 6;
#[doc = " An enumeration of resource states."]
pub type FfxResourceStates = ::std::os::raw::c_uint;
#[doc = "< A resource with a single dimension."]
pub const FfxResourceDimension_FFX_RESOURCE_DIMENSION_TEXTURE_1D: FfxResourceDimension = 0;
#[doc = "< A resource with two dimensions."]
pub const FfxResourceDimension_FFX_RESOURCE_DIMENSION_TEXTURE_2D: FfxResourceDimension = 1;
#[doc = " An enumeration of surface dimensions."]
pub type FfxResourceDimension = ::std::os::raw::c_uint;
#[doc = "< No flags."]
pub const FfxResourceFlags_FFX_RESOURCE_FLAGS_NONE: FfxResourceFlags = 0;
#[doc = "< A bit indicating a resource does not need to persist across frames."]
pub const FfxResourceFlags_FFX_RESOURCE_FLAGS_ALIASABLE: FfxResourceFlags = 1;
#[doc = " An enumeration of surface dimensions."]
pub type FfxResourceFlags = ::std::os::raw::c_uint;
#[doc = "< The resource view is an unordered access view (UAV)."]
pub const FfxResourceViewType_FFX_RESOURCE_VIEW_UNORDERED_ACCESS: FfxResourceViewType = 0;
#[doc = "< The resource view is a shader resource view (SRV)."]
pub const FfxResourceViewType_FFX_RESOURCE_VIEW_SHADER_READ: FfxResourceViewType = 1;
#[doc = " An enumeration of all resource view types."]
pub type FfxResourceViewType = ::std::os::raw::c_uint;
#[doc = "< Point sampling."]
pub const FfxFilterType_FFX_FILTER_TYPE_POINT: FfxFilterType = 0;
#[doc = "< Sampling with interpolation."]
pub const FfxFilterType_FFX_FILTER_TYPE_LINEAR: FfxFilterType = 1;
#[doc = " The type of filtering to perform when reading a texture."]
pub type FfxFilterType = ::std::os::raw::c_uint;
#[doc = "< Shader model 5.1."]
pub const FfxShaderModel_FFX_SHADER_MODEL_5_1: FfxShaderModel = 0;
#[doc = "< Shader model 6.0."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_0: FfxShaderModel = 1;
#[doc = "< Shader model 6.1."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_1: FfxShaderModel = 2;
#[doc = "< Shader model 6.2."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_2: FfxShaderModel = 3;
#[doc = "< Shader model 6.3."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_3: FfxShaderModel = 4;
#[doc = "< Shader model 6.4."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_4: FfxShaderModel = 5;
#[doc = "< Shader model 6.5."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_5: FfxShaderModel = 6;
#[doc = "< Shader model 6.6."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_6: FfxShaderModel = 7;
#[doc = "< Shader model 6.7."]
pub const FfxShaderModel_FFX_SHADER_MODEL_6_7: FfxShaderModel = 8;
#[doc = " An enumeration of all supported shader models."]
pub type FfxShaderModel = ::std::os::raw::c_uint;
#[doc = "< The resource is a buffer."]
pub const FfxResourceType_FFX_RESOURCE_TYPE_BUFFER: FfxResourceType = 0;
#[doc = "< The resource is a 1-dimensional texture."]
pub const FfxResourceType_FFX_RESOURCE_TYPE_TEXTURE1D: FfxResourceType = 1;
#[doc = "< The resource is a 2-dimensional texture."]
pub const FfxResourceType_FFX_RESOURCE_TYPE_TEXTURE2D: FfxResourceType = 2;
#[doc = "< The resource is a 3-dimensional texture."]
pub const FfxResourceType_FFX_RESOURCE_TYPE_TEXTURE3D: FfxResourceType = 3;
pub type FfxResourceType = ::std::os::raw::c_uint;
#[doc = "< Local memory."]
pub const FfxHeapType_FFX_HEAP_TYPE_DEFAULT: FfxHeapType = 0;
#[doc = "< Heap used for uploading resources."]
pub const FfxHeapType_FFX_HEAP_TYPE_UPLOAD: FfxHeapType = 1;
#[doc = " An enumeration for different heap types"]
pub type FfxHeapType = ::std::os::raw::c_uint;
#[doc = "< The GPU job is performing a floating-point clear."]
pub const FfxGpuJobType_FFX_GPU_JOB_CLEAR_FLOAT: FfxGpuJobType = 0;
#[doc = "< The GPU job is performing a copy."]
pub const FfxGpuJobType_FFX_GPU_JOB_COPY: FfxGpuJobType = 1;
#[doc = "< The GPU job is performing a compute dispatch."]
pub const FfxGpuJobType_FFX_GPU_JOB_COMPUTE: FfxGpuJobType = 2;
#[doc = " An enumberation for different render job types"]
pub type FfxGpuJobType = ::std::os::raw::c_uint;
#[doc = " A typedef representing the graphics device."]
pub type FfxDevice = *mut ::std::os::raw::c_void;
#[doc = " A typedef representing a command list or command buffer."]
pub type FfxCommandList = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a root signature."]
pub type FfxRootSignature = *mut ::std::os::raw::c_void;
#[doc = " A typedef for a pipeline state object."]
pub type FfxPipeline = *mut ::std::os::raw::c_void;
#[doc = " A structure encapasulating a collection of device capabilities."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxDeviceCapabilities {
    #[doc = "< The minimum shader model supported by the device."]
    pub minimumSupportedShaderModel: FfxShaderModel,
    #[doc = "< The minimum supported wavefront width."]
    pub waveLaneCountMin: u32,
    #[doc = "< The maximum supported wavefront width."]
    pub waveLaneCountMax: u32,
    #[doc = "< The device supports FP16 in hardware."]
    pub fp16Supported: bool,
    #[doc = "< The device supports raytracing."]
    pub raytracingSupported: bool,
}
#[doc = " A structure encapsulating a 2-dimensional point, using 32bit unsigned integers."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxDimensions2D {
    #[doc = "< The width of a 2-dimensional range."]
    pub width: u32,
    #[doc = "< The height of a 2-dimensional range."]
    pub height: u32,
}
#[doc = " A structure encapsulating a 2-dimensional point,"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxIntCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: i32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: i32,
}
#[doc = " A structure encapsulating a 2-dimensional set of floating point coordinates."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFloatCoords2D {
    #[doc = "< The x coordinate of a 2-dimensional point."]
    pub x: f32,
    #[doc = "< The y coordinate of a 2-dimensional point."]
    pub y: f32,
}
#[doc = " A structure describing a resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxResourceDescription {
    #[doc = "< The type of the resource."]
    pub type_: FfxResourceType,
    #[doc = "< The surface format."]
    pub format: FfxSurfaceFormat,
    #[doc = "< The width of the resource."]
    pub width: u32,
    #[doc = "< The height of the resource."]
    pub height: u32,
    #[doc = "< The depth of the resource."]
    pub depth: u32,
    #[doc = "< Number of mips (or 0 for full mipchain)."]
    pub mipCount: u32,
    #[doc = "< A set of <c><i>FfxResourceFlags</i></c> flags."]
    pub flags: FfxResourceFlags,
}
#[doc = " An outward facing structure containing a resource"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxResource {
    #[doc = "< pointer to the resource."]
    pub resource: *mut ::std::os::raw::c_void,
    pub name: [u32; 64usize],
    pub description: FfxResourceDescription,
    pub state: FfxResourceStates,
    pub isDepth: bool,
    pub descriptorData: u64,
}
#[doc = " An internal structure containing a handle to a resource and resource views"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxResourceInternal {
    #[doc = "< The index of the resource."]
    pub internalIndex: i32,
}
#[doc = " A structure defining a resource bind point"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxResourceBinding {
    pub slotIndex: u32,
    pub resourceIdentifier: u32,
    pub name: [u32; 64usize],
}
#[doc = " A structure encapsulating a single pass of an algorithm."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxPipelineState {
    #[doc = "< The pipelines rootSignature"]
    pub rootSignature: FfxRootSignature,
    #[doc = "< The pipeline object"]
    pub pipeline: FfxPipeline,
    #[doc = "< Count of UAVs used in this pipeline"]
    pub uavCount: u32,
    #[doc = "< Count of SRVs used in this pipeline"]
    pub srvCount: u32,
    #[doc = "< Count of constant buffers used in this pipeline"]
    pub constCount: u32,
    #[doc = "< Array of ResourceIdentifiers bound as UAVs"]
    pub uavResourceBindings: [FfxResourceBinding; 8usize],
    #[doc = "< Array of ResourceIdentifiers bound as SRVs"]
    pub srvResourceBindings: [FfxResourceBinding; 16usize],
    #[doc = "< Array of ResourceIdentifiers bound as CBs"]
    pub cbResourceBindings: [FfxResourceBinding; 2usize],
}
#[doc = " A structure containing the data required to create a resource."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxCreateResourceDescription {
    #[doc = "< The heap type to hold the resource, typically <c><i>FFX_HEAP_TYPE_DEFAULT</i></c>."]
    pub heapType: FfxHeapType,
    #[doc = "< A resource description."]
    pub resourceDescription: FfxResourceDescription,
    #[doc = "< The initial resource state."]
    pub initalState: FfxResourceStates,
    #[doc = "< Size of initial data buffer."]
    pub initDataSize: u32,
    #[doc = "< Buffer containing data to fill the resource."]
    pub initData: *mut ::std::os::raw::c_void,
    #[doc = "< Name of the resource."]
    pub name: *const u32,
    #[doc = "< Resource usage flags."]
    pub usage: FfxResourceUsage,
    #[doc = "< Internal resource ID."]
    pub id: u32,
}
#[doc = " A structure containing the description used to create a\n <c><i>FfxPipeline</i></c> structure.\n\n A pipeline is the name given to a shader and the collection of state that\n is required to dispatch it. In the context of FSR2 and its architecture\n this means that a <c><i>FfxPipelineDescription</i></c> will map to either a\n monolithic object in an explicit API (such as a\n <c><i>PipelineStateObject</i></c> in DirectX 12). Or a shader and some\n ancillary API objects (in something like DirectX 11).\n\n The <c><i>contextFlags</i></c> field contains a copy of the flags passed\n to <c><i>ffxFsr2ContextCreate</i></c> via the <c><i>flags</i></c> field of\n the <c><i>FfxFsr2InitializationParams</i></c> structure. These flags are\n used to determine which permutation of a pipeline for a specific\n <c><i>FfxFsr2Pass</i></c> should be used to implement the features required\n by each application, as well as to acheive the best performance on specific\n target hardware configurations.\n\n When using one of the provided backends for FSR2 (such as DirectX 12 or\n Vulkan) the data required to create a pipeline is compiled offline and\n included into the backend library that you are using. For cases where the\n backend interface is overriden by providing custom callback function\n implementations care should be taken to respect the contents of the\n <c><i>contextFlags</i></c> field in order to correctly support the options\n provided by FSR2, and acheive best performance.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxPipelineDescription {
    #[doc = "< A collection of <c><i>FfxFsr2InitializationFlagBits</i></c> which were passed to the context."]
    pub contextFlags: u32,
    #[doc = "< Array of static samplers."]
    pub samplers: *mut FfxFilterType,
    #[doc = "< The number of samples contained inside <c><i>samplers</i></c>."]
    pub samplerCount: usize,
    #[doc = "< Array containing the sizes of the root constant buffers (count of 32 bit elements)."]
    pub rootConstantBufferSizes: *const u32,
    #[doc = "< The number of root constants contained within <c><i>rootConstantBufferSizes</i></c>."]
    pub rootConstantBufferCount: u32,
}
#[doc = " A structure containing a constant buffer."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxConstantBuffer {
    #[doc = "< Size of 32 bit chunks used in the constant buffer"]
    pub uint32Size: u32,
    #[doc = "< Constant buffer data"]
    pub data: [u32; 64usize],
}
#[doc = " A structure describing a clear render job."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxClearFloatJobDescription {
    #[doc = "< The clear color of the resource."]
    pub color: [f32; 4usize],
    #[doc = "< The resource to be cleared."]
    pub target: FfxResourceInternal,
}
#[doc = " A structure describing a compute render job."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxComputeJobDescription {
    #[doc = "< Compute pipeline for the render job."]
    pub pipeline: FfxPipelineState,
    #[doc = "< Dispatch dimensions."]
    pub dimensions: [u32; 3usize],
    #[doc = "< SRV resources to be bound in the compute job."]
    pub srvs: [FfxResourceInternal; 16usize],
    pub srvNames: [[u32; 64usize]; 16usize],
    #[doc = "< UAV resources to be bound in the compute job."]
    pub uavs: [FfxResourceInternal; 8usize],
    #[doc = "< Mip level of UAV resources to be bound in the compute job."]
    pub uavMip: [u32; 8usize],
    pub uavNames: [[u32; 64usize]; 8usize],
    #[doc = "< Constant buffers to be bound in the compute job."]
    pub cbs: [FfxConstantBuffer; 2usize],
    pub cbNames: [[u32; 64usize]; 2usize],
}
#[doc = " A structure describing a copy render job."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxCopyJobDescription {
    #[doc = "< Source resource for the copy."]
    pub src: FfxResourceInternal,
    #[doc = "< Destination resource for the copy."]
    pub dst: FfxResourceInternal,
}
#[doc = " A structure describing a single render job."]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct FfxGpuJobDescription {
    #[doc = "< Type of the job."]
    pub jobType: FfxGpuJobType,
    pub __bindgen_anon_1: FfxGpuJobDescription__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union FfxGpuJobDescription__bindgen_ty_1 {
    #[doc = "< Clear job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_CLEAR_FLOAT</i></c>."]
    pub clearJobDescriptor: FfxClearFloatJobDescription,
    #[doc = "< Copy job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COPY</i></c>."]
    pub copyJobDescriptor: FfxCopyJobDescription,
    #[doc = "< Compute job descriptor. Valid when <c><i>jobType</i></c> is <c><i>FFX_RENDER_JOB_COMPUTE</i></c>."]
    pub computeJobDescriptor: FfxComputeJobDescription,
}
#[doc = " The value of Pi."]
pub const FFX_PI: f32 = 3.1415927410125732;
#[doc = " An epsilon value for floating point numbers."]
pub const FFX_EPSILON: f32 = 0.0000009999999974752427;
#[doc = " A typedef for the callback function for assert printing.\n\n This can be used to re-route printing of assert messages from the FFX backend\n to another destination. For example instead of the default behaviour of printing\n the assert messages to the debugger's TTY the message can be re-routed to a\n MessageBox in a GUI application.\n\n @param [in] message                 The message generated by the assert.\n"]
pub type FfxAssertCallback =
    ::std::option::Option<unsafe extern "C" fn(message: *const ::std::os::raw::c_char)>;
extern "C" {
    #[doc = " Function to report an assert.\n\n @param [in] file                    The name of the file as a string.\n @param [in] line                    The index of the line in the file.\n @param [in] condition               The boolean condition that was tested.\n @param [in] msg                     The optional message to print.\n\n @returns\n Always returns true.\n"]
    pub fn ffxAssertReport(
        file: *const ::std::os::raw::c_char,
        line: i32,
        condition: *const ::std::os::raw::c_char,
        msg: *const ::std::os::raw::c_char,
    ) -> bool;
}
extern "C" {
    #[doc = " Provides the ability to set a callback for assert messages.\n\n @param [in] callback                The callback function that will receive assert messages.\n"]
    pub fn ffxAssertSetPrintingCallback(callback: FfxAssertCallback);
}
#[doc = " Typedef for error codes returned from functions in the FidelityFX SDK."]
pub type FfxErrorCode = i32;
#[doc = "< The operation completed successfully."]
pub const FFX_OK: FfxErrorCode = 0;
#[doc = "< The operation failed due to an invalid pointer."]
pub const FFX_ERROR_INVALID_POINTER: FfxErrorCode = -2147483648;
#[doc = "< The operation failed due to an invalid alignment."]
pub const FFX_ERROR_INVALID_ALIGNMENT: FfxErrorCode = -2147483647;
#[doc = "< The operation failed due to an invalid size."]
pub const FFX_ERROR_INVALID_SIZE: FfxErrorCode = -2147483646;
#[doc = "< The end of the file was encountered."]
pub const FFX_EOF: FfxErrorCode = -2147483645;
#[doc = "< The operation failed because the specified path was invalid."]
pub const FFX_ERROR_INVALID_PATH: FfxErrorCode = -2147483644;
#[doc = "< The operation failed because end of file was reached."]
pub const FFX_ERROR_EOF: FfxErrorCode = -2147483643;
#[doc = "< The operation failed because of some malformed data."]
pub const FFX_ERROR_MALFORMED_DATA: FfxErrorCode = -2147483642;
#[doc = "< The operation failed because it ran out memory."]
pub const FFX_ERROR_OUT_OF_MEMORY: FfxErrorCode = -2147483641;
#[doc = "< The operation failed because the interface was not fully configured."]
pub const FFX_ERROR_INCOMPLETE_INTERFACE: FfxErrorCode = -2147483640;
#[doc = "< The operation failed because of an invalid enumeration value."]
pub const FFX_ERROR_INVALID_ENUM: FfxErrorCode = -2147483639;
#[doc = "< The operation failed because an argument was invalid."]
pub const FFX_ERROR_INVALID_ARGUMENT: FfxErrorCode = -2147483638;
#[doc = "< The operation failed because a value was out of range."]
pub const FFX_ERROR_OUT_OF_RANGE: FfxErrorCode = -2147483637;
#[doc = "< The operation failed because a device was null."]
pub const FFX_ERROR_NULL_DEVICE: FfxErrorCode = -2147483636;
#[doc = "< The operation failed because the backend API returned an error code."]
pub const FFX_ERROR_BACKEND_API_ERROR: FfxErrorCode = -2147483635;
#[doc = "< The operation failed because there was not enough memory."]
pub const FFX_ERROR_INSUFFICIENT_MEMORY: FfxErrorCode = -2147483634;
#[doc = "< A pass which prepares input colors for subsequent use."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_PREPARE_INPUT_COLOR: FfxFsr2Pass = 0;
#[doc = "< A pass which performs depth clipping."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_DEPTH_CLIP: FfxFsr2Pass = 1;
#[doc = "< A pass which performs reconstruction of previous frame's depth."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_RECONSTRUCT_PREVIOUS_DEPTH: FfxFsr2Pass = 2;
#[doc = "< A pass which calculates pixel locks."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_LOCK: FfxFsr2Pass = 3;
#[doc = "< A pass which performs upscaling."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_ACCUMULATE: FfxFsr2Pass = 4;
#[doc = "< A pass which performs upscaling when sharpening is used."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_ACCUMULATE_SHARPEN: FfxFsr2Pass = 5;
#[doc = "< A pass which performs sharpening."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_RCAS: FfxFsr2Pass = 6;
#[doc = "< A pass which generates the luminance mipmap chain for the current frame."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_COMPUTE_LUMINANCE_PYRAMID: FfxFsr2Pass = 7;
#[doc = "< An optional pass to generate a reactive mask"]
pub const FfxFsr2Pass_FFX_FSR2_PASS_GENERATE_REACTIVE: FfxFsr2Pass = 8;
#[doc = "< The number of passes performed by FSR2."]
pub const FfxFsr2Pass_FFX_FSR2_PASS_COUNT: FfxFsr2Pass = 9;
#[doc = " An enumeration of all the passes which constitute the FSR2 algorithm.\n\n FSR2 is implemented as a composite of several compute passes each\n computing a key part of the final result. Each call to the\n <c><i>FfxFsr2ScheduleGpuJobFunc</i></c> callback function will\n correspond to a single pass included in <c><i>FfxFsr2Pass</i></c>. For a\n more comprehensive description of each pass, please refer to the FSR2\n reference documentation.\n\n Please note in some cases e.g.: <c><i>FFX_FSR2_PASS_ACCUMULATE</i></c>\n and <c><i>FFX_FSR2_PASS_ACCUMULATE_SHARPEN</i></c> either one pass or the\n other will be used (they are mutually exclusive). The choice of which will\n depend on the way the <c><i>FfxFsr2Context</i></c> is created and the\n precise contents of <c><i>FfxFsr2DispatchParamters</i></c> each time a call\n is made to <c><i>ffxFsr2ContextDispatch</i></c>.\n\n @ingroup FSR2"]
pub type FfxFsr2Pass = ::std::os::raw::c_uint;
#[doc = " Create and initialize the backend context.\n\n The callback function sets up the backend context for rendering.\n It will create or reference the device and create required internal data structures.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] device                              The FfxDevice obtained by ffxGetDevice(DX12/VK/...).\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2CreateBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        device: FfxDevice,
    ) -> FfxErrorCode,
>;
#[doc = " Get a list of capabilities of the device.\n\n When creating an <c><i>FfxFsr2Context</i></c> it is desirable for the FSR2\n core implementation to be aware of certain characteristics of the platform\n that is being targetted. This is because some optimizations which FSR2\n attempts to perform are more effective on certain classes of hardware than\n others, or are not supported by older hardware. In order to avoid cases\n where optimizations actually have the effect of decreasing performance, or\n reduce the breadth of support provided by FSR2, FSR2 queries the\n capabilities of the device to make such decisions.\n\n For target platforms with fixed hardware support you need not implement\n this callback function by querying the device, but instead may hardcore\n what features are available on the platform.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] outDeviceCapabilities              The device capabilities structure to fill out.\n @param [in] device                              The device to query for capabilities.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2GetDeviceCapabilitiesFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        outDeviceCapabilities: *mut FfxDeviceCapabilities,
        device: FfxDevice,
    ) -> FfxErrorCode,
>;
#[doc = " Destroy the backend context and dereference the device.\n\n This function is called when the <c><i>FfxFsr2Context</i></c> is destroyed.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2DestroyBackendContextFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut FfxFsr2Interface) -> FfxErrorCode,
>;
#[doc = " Create a resource.\n\n This callback is intended for the backend to create internal resources.\n\n Please note: It is also possible that the creation of resources might\n itself cause additional resources to be created by simply calling the\n <c><i>FfxFsr2CreateResourceFunc</i></c> function pointer again. This is\n useful when handling the initial creation of resources which must be\n initialized. The flow in such a case would be an initial call to create the\n CPU-side resource, another to create the GPU-side resource, and then a call\n to schedule a copy render job to move the data between the two. Typically\n this type of function call flow is only seen during the creation of an\n <c><i>FfxFsr2Context</i></c>.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] createResourceDescription           A pointer to a <c><i>FfxCreateResourceDescription</i></c>.\n @param [out] outResource                        A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2CreateResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        createResourceDescription: *const FfxCreateResourceDescription,
        outResource: *mut FfxResourceInternal,
    ) -> FfxErrorCode,
>;
#[doc = " Register a resource in the backend for the current frame.\n\n Since FSR2 and the backend are not aware how many different\n resources will get passed to FSR2 over time, it's not safe\n to register all resources simultaneously in the backend.\n Also passed resources may not be valid after the dispatch call.\n As a result it's safest to register them as FfxResourceInternal\n and clear them at the end of the dispatch call.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] inResource                          A pointer to a <c><i>FfxResource</i></c>.\n @param [out] outResource                        A pointer to a <c><i>FfxResourceInternal</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2RegisterResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        inResource: *const FfxResource,
        outResource: *mut FfxResourceInternal,
    ) -> FfxErrorCode,
>;
#[doc = " Unregister all temporary FfxResourceInternal from the backend.\n\n Unregister FfxResourceInternal referencing resources passed to\n a function as a parameter.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2UnregisterResourcesFunc = ::std::option::Option<
    unsafe extern "C" fn(backendInterface: *mut FfxFsr2Interface) -> FfxErrorCode,
>;
#[doc = " Retrieve a <c><i>FfxResourceDescription</i></c> matching a\n <c><i>FfxResource</i></c> structure.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @returns\n A description of the resource.\n\n @ingroup FSR2"]
pub type FfxFsr2GetResourceDescriptionFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        resource: FfxResourceInternal,
    ) -> FfxResourceDescription,
>;
#[doc = " Destroy a resource\n\n This callback is intended for the backend to release an internal resource.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] resource                            A pointer to a <c><i>FfxResource</i></c> object.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2DestroyResourceFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        resource: FfxResourceInternal,
    ) -> FfxErrorCode,
>;
#[doc = " Create a render pipeline.\n\n A rendering pipeline contains the shader as well as resource bindpoints\n and samplers.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] pass                                The identifier for the pass.\n @param [in] pipelineDescription                 A pointer to a <c><i>FfxPipelineDescription</i></c> describing the pipeline to be created.\n @param [out] outPipeline                        A pointer to a <c><i>FfxPipelineState</i></c> structure which should be populated.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2CreatePipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        pass: FfxFsr2Pass,
        pipelineDescription: *const FfxPipelineDescription,
        outPipeline: *mut FfxPipelineState,
    ) -> FfxErrorCode,
>;
#[doc = " Destroy a render pipeline.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [out] pipeline                           A pointer to a <c><i>FfxPipelineState</i></c> structure which should be released.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2DestroyPipelineFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        pipeline: *mut FfxPipelineState,
    ) -> FfxErrorCode,
>;
#[doc = " Schedule a render job to be executed on the next call of\n <c><i>FfxFsr2ExecuteGpuJobsFunc</i></c>.\n\n Render jobs can perform one of three different tasks: clear, copy or\n compute dispatches.\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] job                                 A pointer to a <c><i>FfxGpuJobDescription</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2ScheduleGpuJobFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        job: *const FfxGpuJobDescription,
    ) -> FfxErrorCode,
>;
#[doc = " Execute scheduled render jobs on the <c><i>comandList</i></c> provided.\n\n The recording of the graphics API commands should take place in this\n callback function, the render jobs which were previously enqueued (via\n callbacks made to <c><i>FfxFsr2ScheduleGpuJobFunc</i></c>) should be\n processed in the order they were received. Advanced users might choose to\n reorder the rendering jobs, but should do so with care to respect the\n resource dependencies.\n\n Depending on the precise contents of <c><i>FfxFsr2DispatchDescription</i></c> a\n different number of render jobs might have previously been enqueued (for\n example if sharpening is toggled on and off).\n\n @param [in] backendInterface                    A pointer to the backend interface.\n @param [in] commandList                         A pointer to a <c><i>FfxCommandList</i></c> structure.\n\n @retval\n FFX_OK                                          The operation completed successfully.\n @retval\n Anything else                                   The operation failed.\n\n @ingroup FSR2"]
pub type FfxFsr2ExecuteGpuJobsFunc = ::std::option::Option<
    unsafe extern "C" fn(
        backendInterface: *mut FfxFsr2Interface,
        commandList: FfxCommandList,
    ) -> FfxErrorCode,
>;
#[doc = " A structure encapsulating the interface between the core implentation of\n the FSR2 algorithm and any graphics API that it should ultimately call.\n\n This set of functions serves as an abstraction layer between FSR2 and the\n API used to implement it. While FSR2 ships with backends for DirectX12 and\n Vulkan, it is possible to implement your own backend for other platforms or\n which sits ontop of your engine's own abstraction layer. For details on the\n expectations of what each function should do you should refer the\n description of the following function pointer types:\n\n     <c><i>FfxFsr2CreateDeviceFunc</i></c>\n     <c><i>FfxFsr2GetDeviceCapabilitiesFunc</i></c>\n     <c><i>FfxFsr2DestroyDeviceFunc</i></c>\n     <c><i>FfxFsr2CreateResourceFunc</i></c>\n     <c><i>FfxFsr2GetResourceDescriptionFunc</i></c>\n     <c><i>FfxFsr2DestroyResourceFunc</i></c>\n     <c><i>FfxFsr2CreatePipelineFunc</i></c>\n     <c><i>FfxFsr2DestroyPipelineFunc</i></c>\n     <c><i>FfxFsr2ScheduleGpuJobFunc</i></c>\n     <c><i>FfxFsr2ExecuteGpuJobsFunc</i></c>\n\n Depending on the graphics API that is abstracted by the backend, it may be\n required that the backend is to some extent stateful. To ensure that\n applications retain full control to manage the memory used by FSR2, the\n <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields are\n provided. A backend should provide a means of specifying how much scratch\n memory is required for its internal implementation (e.g: via a function\n or constant value). The application is that responsible for allocating that\n memory and providing it when setting up the FSR2 backend. Backends provided\n with FSR2 do not perform dynamic memory allocations, and instead\n suballocate all memory from the scratch buffers provided.\n\n The <c><i>scratchBuffer</i></c> and <c><i>scratchBufferSize</i></c> fields\n should be populated according to the requirements of each backend. For\n example, if using the DirectX 12 backend you should call the\n <c><i>ffxFsr2GetScratchMemorySizeDX12</i></c> function. It is not required\n that custom backend implementations use a scratch buffer.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2Interface {
    #[doc = "< A callback function to create and initialize the backend context."]
    pub fpCreateBackendContext: FfxFsr2CreateBackendContextFunc,
    #[doc = "< A callback function to query device capabilites."]
    pub fpGetDeviceCapabilities: FfxFsr2GetDeviceCapabilitiesFunc,
    #[doc = "< A callback function to destroy the backendcontext. This also dereferences the device."]
    pub fpDestroyBackendContext: FfxFsr2DestroyBackendContextFunc,
    #[doc = "< A callback function to create a resource."]
    pub fpCreateResource: FfxFsr2CreateResourceFunc,
    #[doc = "< A callback function to register an external resource."]
    pub fpRegisterResource: FfxFsr2RegisterResourceFunc,
    #[doc = "< A callback function to unregister external resource."]
    pub fpUnregisterResources: FfxFsr2UnregisterResourcesFunc,
    #[doc = "< A callback function to retrieve a resource description."]
    pub fpGetResourceDescription: FfxFsr2GetResourceDescriptionFunc,
    #[doc = "< A callback function to destroy a resource."]
    pub fpDestroyResource: FfxFsr2DestroyResourceFunc,
    #[doc = "< A callback function to create a render or compute pipeline."]
    pub fpCreatePipeline: FfxFsr2CreatePipelineFunc,
    #[doc = "< A callback function to destroy a render or compute pipeline."]
    pub fpDestroyPipeline: FfxFsr2DestroyPipelineFunc,
    #[doc = "< A callback function to schedule a render job."]
    pub fpScheduleGpuJob: FfxFsr2ScheduleGpuJobFunc,
    #[doc = "< A callback function to execute all queued render jobs."]
    pub fpExecuteGpuJobs: FfxFsr2ExecuteGpuJobsFunc,
    #[doc = "< A preallocated buffer for memory utilized internally by the backend."]
    pub scratchBuffer: *mut ::std::os::raw::c_void,
    #[doc = "< Size of the buffer pointed to by <c><i>scratchBuffer</i></c>."]
    pub scratchBufferSize: usize,
}
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.5x."]
pub const FfxFsr2QualityMode_FFX_FSR2_QUALITY_MODE_QUALITY: FfxFsr2QualityMode = 1;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 1.7x."]
pub const FfxFsr2QualityMode_FFX_FSR2_QUALITY_MODE_BALANCED: FfxFsr2QualityMode = 2;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 2.0x."]
pub const FfxFsr2QualityMode_FFX_FSR2_QUALITY_MODE_PERFORMANCE: FfxFsr2QualityMode = 3;
#[doc = "< Perform upscaling with a per-dimension upscaling ratio of 3.0x."]
pub const FfxFsr2QualityMode_FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE: FfxFsr2QualityMode = 4;
#[doc = " An enumeration of all the quality modes supported by FidelityFX Super\n Resolution 2 upscaling.\n\n In order to provide a consistent user experience across multiple\n applications which implement FSR2. It is strongly recommended that the\n following preset scaling factors are made available through your\n application's user interface.\n\n If your application does not expose the notion of preset scaling factors\n for upscaling algorithms (perhaps instead implementing a fixed ratio which\n is immutable) or implementing a more dynamic scaling scheme (such as\n dynamic resolution scaling), then there is no need to use these presets.\n\n Please note that <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> is\n an optional mode which may introduce significant quality degradation in the\n final image. As such it is recommended that you evaluate the final results\n of using this scaling mode before deciding if you should include it in your\n application.\n\n @ingroup FSR2"]
pub type FfxFsr2QualityMode = ::std::os::raw::c_uint;
#[doc = "< A bit indicating if the input color data provided is using a high-dynamic range."]
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_HIGH_DYNAMIC_RANGE:
    FfxFsr2InitializationFlagBits = 1;
#[doc = "< A bit indicating if the motion vectors are rendered at display resolution."]
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS:
    FfxFsr2InitializationFlagBits = 2;
#[doc = "< A bit indicating that the motion vectors have the jittering pattern applied to them."]
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_MOTION_VECTORS_JITTER_CANCELLATION:
    FfxFsr2InitializationFlagBits = 4;
#[doc = "< A bit indicating that the input depth buffer data provided is inverted [1..0]."]
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_DEPTH_INVERTED:
    FfxFsr2InitializationFlagBits = 8;
#[doc = "< A bit indicating that the input depth buffer data provided is using an infinite far plane."]
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_DEPTH_INFINITE:
    FfxFsr2InitializationFlagBits = 16;
#[doc = "< A bit indicating if automatic exposure should be applied to input color data."]
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_AUTO_EXPOSURE:
    FfxFsr2InitializationFlagBits = 32;
#[doc = "< A bit indicating that the application uses dynamic resolution scaling."]
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_DYNAMIC_RESOLUTION:
    FfxFsr2InitializationFlagBits = 64;
#[doc = "< A bit indicating that the backend should use 1D textures."]
pub const FfxFsr2InitializationFlagBits_FFX_FSR2_ENABLE_TEXTURE1D_USAGE:
    FfxFsr2InitializationFlagBits = 128;
#[doc = " An enumeration of bit flags used when creating a\n <c><i>FfxFsr2Context</i></c>. See <c><i>FfxFsr2ContextDescription</i></c>.\n\n @ingroup FSR2"]
pub type FfxFsr2InitializationFlagBits = ::std::os::raw::c_uint;
#[doc = " A structure encapsulating the parameters required to initialize FidelityFX\n Super Resolution 2 upscaling.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2ContextDescription {
    #[doc = "< A collection of <c><i>FfxFsr2InitializationFlagBits</i></c>."]
    pub flags: u32,
    #[doc = "< The maximum size that rendering will be performed at."]
    pub maxRenderSize: FfxDimensions2D,
    #[doc = "< The size of the presentation resolution targeted by the upscaling process."]
    pub displaySize: FfxDimensions2D,
    #[doc = "< A set of pointers to the backend implementation for FSR 2.0."]
    pub callbacks: FfxFsr2Interface,
    #[doc = "< The abstracted device which is passed to some callback functions."]
    pub device: FfxDevice,
}
#[doc = " A structure encapsulating the parameters for dispatching the various passes\n of FidelityFX Super Resolution 2.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2DispatchDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: FfxCommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the color buffer for the current frame (at render resolution)."]
    pub color: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 32bit depth values for the current frame (at render resolution)."]
    pub depth: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing 2-dimensional motion vectors (at render resolution if <c><i>FFX_FSR2_ENABLE_DISPLAY_RESOLUTION_MOTION_VECTORS</i></c> is not set)."]
    pub motionVectors: FfxResource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing a 1x1 exposure value."]
    pub exposure: FfxResource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of reactive objects in the scene."]
    pub reactive: FfxResource,
    #[doc = "< A optional <c><i>FfxResource</i></c> containing alpha value of special objects in the scene."]
    pub transparencyAndComposition: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the output color buffer for the current frame (at presentation resolution)."]
    pub output: FfxResource,
    #[doc = "< The subpixel jitter offset applied to the camera."]
    pub jitterOffset: FfxFloatCoords2D,
    #[doc = "< The scale factor to apply to motion vectors."]
    pub motionVectorScale: FfxFloatCoords2D,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: FfxDimensions2D,
    #[doc = "< Enable an additional sharpening pass."]
    pub enableSharpening: bool,
    #[doc = "< The sharpness value between 0 and 1, where 0 is no additional sharpness and 1 is maximum additional sharpness."]
    pub sharpness: f32,
    #[doc = "< The time elapsed since the last frame (expressed in milliseconds)."]
    pub frameTimeDelta: f32,
    #[doc = "< The exposure value if not using <c><i>FFX_FSR2_ENABLE_AUTO_EXPOSURE</i></c>."]
    pub preExposure: f32,
    #[doc = "< A boolean value which when set to true, indicates the camera has moved discontinuously."]
    pub reset: bool,
    #[doc = "< The distance to the near plane of the camera."]
    pub cameraNear: f32,
    #[doc = "< The distance to the far plane of the camera. This is used only used in case of non infinite depth."]
    pub cameraFar: f32,
    #[doc = "< The camera angle field of view in the vertical direction (expressed in radians)."]
    pub cameraFovAngleVertical: f32,
}
#[doc = " A structure encapsulating the parameters for automatic generation of a reactive mask\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2GenerateReactiveDescription {
    #[doc = "< The <c><i>FfxCommandList</i></c> to record FSR2 rendering commands into."]
    pub commandList: FfxCommandList,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque only color buffer for the current frame (at render resolution)."]
    pub colorOpaqueOnly: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the opaque+translucent color buffer for the current frame (at render resolution)."]
    pub colorPreUpscale: FfxResource,
    #[doc = "< A <c><i>FfxResource</i></c> containing the surface to generate the reactive mask into."]
    pub outReactive: FfxResource,
    #[doc = "< The resolution that was used for rendering the input resources."]
    pub renderSize: FfxDimensions2D,
    #[doc = "< A value to scale the output"]
    pub scale: f32,
    #[doc = "< A threshold value to generate a binary reactive mask"]
    pub cutoffThreshold: f32,
    #[doc = "< A value to set for the binary reactive mask"]
    pub binaryValue: f32,
    #[doc = "< Flags to determine how to generate the reactive mask"]
    pub flags: u32,
}
#[doc = " A structure encapsulating the FidelityFX Super Resolution 2 context.\n\n This sets up an object which contains all persistent internal data and\n resources that are required by FSR2.\n\n The <c><i>FfxFsr2Context</i></c> object should have a lifetime matching\n your use of FSR2. Before destroying the FSR2 context care should be taken\n to ensure the GPU is not accessing the resources created or used by FSR2.\n It is therefore recommended that the GPU is idle before destroying the\n FSR2 context.\n\n @ingroup FSR2"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FfxFsr2Context {
    #[doc = "< An opaque set of <c>uint32_t</c> which contain the data for the context."]
    pub data: [u32; 16536usize],
}
extern "C" {
    #[doc = " Create a FidelityFX Super Resolution 2 context from the parameters\n programmed to the <c><i>FfxFsr2CreateParams</i></c> structure.\n\n The context structure is the main object used to interact with the FSR2\n API, and is responsible for the management of the internal resources used\n by the FSR2 algorithm. When this API is called, multiple calls will be\n made via the pointers contained in the <c><i>callbacks</i></c> structure.\n These callbacks will attempt to retreive the device capabilities, and\n create the internal resources, and pipelines required by FSR2's\n frame-to-frame function. Depending on the precise configuration used when\n creating the <c><i>FfxFsr2Context</i></c> a different set of resources and\n pipelines might be requested via the callback functions.\n\n The flags included in the <c><i>flags</i></c> field of\n <c><i>FfxFsr2Context</i></c> how match the configuration of your\n application as well as the intended use of FSR2. It is important that these\n flags are set correctly (as well as a correct programmed\n <c><i>FfxFsr2DispatchDescription</i></c>) to ensure correct operation. It is\n recommended to consult the overview documentation for further details on\n how FSR2 should be integerated into an application.\n\n When the <c><i>FfxFsr2Context</i></c> is created, you should use the\n <c><i>ffxFsr2ContextDispatch</i></c> function each frame where FSR2\n upscaling should be applied. See the documentation of\n <c><i>ffxFsr2ContextDispatch</i></c> for more details.\n\n The <c><i>FfxFsr2Context</i></c> should be destroyed when use of it is\n completed, typically when an application is unloaded or FSR2 upscaling is\n disabled by a user. To destroy the FSR2 context you should call\n <c><i>ffxFsr2ContextDestroy</i></c>.\n\n @param [out] context                A pointer to a <c><i>FfxFsr2Context</i></c> structure to populate.\n @param [in]  contextDescription     A pointer to a <c><i>FfxFsr2ContextDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>contextDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_INCOMPLETE_INTERFACE      The operation failed because the <c><i>FfxFsr2ContextDescription.callbacks</i></c>  was not fully specified.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ContextCreate(
        context: *mut FfxFsr2Context,
        contextDescription: *const FfxFsr2ContextDescription,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " Dispatch the various passes that constitute FidelityFX Super Resolution 2.\n\n FSR2 is a composite effect, meaning that it is compromised of multiple\n constituent passes (implemented as one or more clears, copies and compute\n dispatches). The <c><i>ffxFsr2ContextDispatch</i></c> function is the\n function which (via the use of the functions contained in the\n <c><i>callbacks</i></c> field of the <c><i>FfxFsr2Context</i></c>\n structure) utlimately generates the sequence of graphics API calls required\n each frame.\n\n As with the creation of the <c><i>FfxFsr2Context</i></c> correctly\n programming the <c><i>FfxFsr2DispatchDescription</i></c> is key to ensuring\n the correct operation of FSR2. It is particularly important to ensure that\n camera jitter is correctly applied to your application's projection matrix\n (or camera origin for raytraced applications). FSR2 provides the\n <c><i>ffxFsr2GetJitterPhaseCount</i></c> and\n <c><i>ffxFsr2GetJitterOffset</i></c> entry points to help applications\n correctly compute the camera jitter. Whatever jitter pattern is used by the\n application it should be correctly programmed to the\n <c><i>jitterOffset</i></c> field of the <c><i>dispatchDescription</i></c>\n structure. For more guidance on camera jitter please consult the\n documentation for <c><i>ffxFsr2GetJitterOffset</i></c> as well as the\n accompanying overview documentation for FSR2.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr2Context</i></c> structure.\n @param [in] dispatchDescription     A pointer to a <c><i>FfxFsr2DispatchDescription</i></c> structure.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> or <c><i>dispatchDescription</i></c> was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_OUT_OF_RANGE              The operation failed because <c><i>dispatchDescription.renderSize</i></c> was larger than the maximum render resolution.\n @retval\n FFX_ERROR_NULL_DEVICE               The operation failed because the device inside the context was <c><i>NULL</i></c>.\n @retval\n FFX_ERROR_BACKEND_API_ERROR         The operation failed because of an error returned from the backend.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ContextDispatch(
        context: *mut FfxFsr2Context,
        dispatchDescription: *const FfxFsr2DispatchDescription,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " A helper function generate a Reactive mask from an opaque only texure and one containing translucent objects.\n\n @param [in] context                 A pointer to a <c><i>FfxFsr2Context</i></c> structure.\n @param [in] params                  A pointer to a <c><i>FfxFsr2GenerateReactiveDescription</i></c> structure\n\n @retval\n FFX_OK                              The operation completed successfully.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ContextGenerateReactiveMask(
        context: *mut FfxFsr2Context,
        params: *const FfxFsr2GenerateReactiveDescription,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " Destroy the FidelityFX Super Resolution context.\n\n @param [out] context                A pointer to a <c><i>FfxFsr2Context</i></c> structure to destroy.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_CODE_NULL_POINTER         The operation failed because either <c><i>context</i></c> was <c><i>NULL</i></c>.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ContextDestroy(context: *mut FfxFsr2Context) -> FfxErrorCode;
}
extern "C" {
    #[doc = " Get the upscale ratio from the quality mode.\n\n The following table enumerates the mapping of the quality modes to\n per-dimension scaling ratios.\n\n Quality preset                                        | Scale factor\n ----------------------------------------------------- | -------------\n <c><i>FFX_FSR2_QUALITY_MODE_QUALITY</i></c>           | 1.5x\n <c><i>FFX_FSR2_QUALITY_MODE_BALANCED</i></c>          | 1.7x\n <c><i>FFX_FSR2_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x\n <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x\n\n Passing an invalid <c><i>qualityMode</i></c> will return 0.0f.\n\n @param [in] qualityMode             The quality mode preset.\n\n @returns\n The upscaling the per-dimension upscaling ratio for\n <c><i>qualityMode</i></c> according to the table above.\n\n @ingroup FSR2"]
    pub fn ffxFsr2GetUpscaleRatioFromQualityMode(qualityMode: FfxFsr2QualityMode) -> f32;
}
extern "C" {
    #[doc = " A helper function to calculate the rendering resolution from a target\n resolution and desired quality level.\n\n This function applies the scaling factor returned by\n <c><i>ffxFsr2GetUpscaleRatioFromQualityMode</i></c> to each dimension.\n\n @param [out] renderWidth            A pointer to a <c>uint32_t</c> which will hold the calculated render resolution width.\n @param [out] renderHeight           A pointer to a <c>uint32_t</c> which will hold the calculated render resolution height.\n @param [in] displayWidth            The target display resolution width.\n @param [in] displayHeight           The target display resolution height.\n @param [in] qualityMode             The desired quality mode for FSR 2 upscaling.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>renderWidth</i></c> or <c><i>renderHeight</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ENUM              An invalid quality mode was specified.\n\n @ingroup FSR2"]
    pub fn ffxFsr2GetRenderResolutionFromQualityMode(
        renderWidth: *mut u32,
        renderHeight: *mut u32,
        displayWidth: u32,
        displayHeight: u32,
        qualityMode: FfxFsr2QualityMode,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " A helper function to calculate the jitter phase count from display\n resolution.\n\n For more detailed information about the application of camera jitter to\n your application's rendering please refer to the\n <c><i>ffxFsr2GetJitterOffset</i></c> function.\n\n The table below shows the jitter phase count which this function\n would return for each of the quality presets.\n\n Quality preset                                        | Scale factor  | Phase count\n ----------------------------------------------------- | ------------- | ---------------\n <c><i>FFX_FSR2_QUALITY_MODE_QUALITY</i></c>           | 1.5x          | 18\n <c><i>FFX_FSR2_QUALITY_MODE_BALANCED</i></c>          | 1.7x          | 23\n <c><i>FFX_FSR2_QUALITY_MODE_PERFORMANCE</i></c>       | 2.0x          | 32\n <c><i>FFX_FSR2_QUALITY_MODE_ULTRA_PERFORMANCE</i></c> | 3.0x          | 72\n Custom                                                | [1..n]x       | ceil(8*n^2)\n\n @param [in] renderWidth             The render resolution width.\n @param [in] displayWidth            The display resolution width.\n\n @returns\n The jitter phase count for the scaling factor between <c><i>renderWidth</i></c> and <c><i>displayWidth</i></c>.\n\n @ingroup FSR2"]
    pub fn ffxFsr2GetJitterPhaseCount(renderWidth: i32, displayWidth: i32) -> i32;
}
extern "C" {
    #[doc = " A helper function to calculate the subpixel jitter offset.\n\n FSR2 relies on the application to apply sub-pixel jittering while rendering.\n This is typically included in the projection matrix of the camera. To make\n the application of camera jitter simple, the FSR2 API provides a small set\n of utility function which computes the sub-pixel jitter offset for a\n particular frame within a sequence of separate jitter offsets. To begin, the\n index within the jitter phase must be computed. To calculate the\n sequence's length, you can call the <c><i>ffxFsr2GetJitterPhaseCount</i></c>\n function. The index should be a value which is incremented each frame modulo\n the length of the sequence computed by <c><i>ffxFsr2GetJitterPhaseCount</i></c>.\n The index within the jitter phase  is passed to\n <c><i>ffxFsr2GetJitterOffset</i></c> via the <c><i>index</i></c> parameter.\n\n This function uses a Halton(2,3) sequence to compute the jitter offset.\n The ultimate index used for the sequence is <c><i>index</i></c> %\n <c><i>phaseCount</i></c>.\n\n It is important to understand that the values returned from the\n <c><i>ffxFsr2GetJitterOffset</i></c> function are in unit pixel space, and\n in order to composite this correctly into a projection matrix we must\n convert them into projection offsets. This is done as per the pseudo code\n listing which is shown below.\n\n     const int32_t jitterPhaseCount = ffxFsr2GetJitterPhaseCount(renderWidth, displayWidth);\n\n     float jitterX = 0;\n     float jitterY = 0;\n     ffxFsr2GetJitterOffset(&jitterX, &jitterY, index, jitterPhaseCount);\n\n     const float jitterX = 2.0f * jitterX / (float)renderWidth;\n     const float jitterY = -2.0f * jitterY / (float)renderHeight;\n     const Matrix4 jitterTranslationMatrix = translateMatrix(Matrix3::identity, Vector3(jitterX, jitterY, 0));\n     const Matrix4 jitteredProjectionMatrix = jitterTranslationMatrix * projectionMatrix;\n\n Jitter should be applied to all rendering. This includes opaque, alpha\n transparent, and raytraced objects. For rasterized objects, the sub-pixel\n jittering values calculated by the <c><i>iffxFsr2GetJitterOffset</i></c>\n function can be applied to the camera projection matrix which is ultimately\n used to perform transformations during vertex shading. For raytraced\n rendering, the sub-pixel jitter should be applied to the ray's origin,\n often the camera's position.\n\n Whether you elect to use the <c><i>ffxFsr2GetJitterOffset</i></c> function\n or your own sequence generator, you must program the\n <c><i>jitterOffset</i></c> field of the\n <c><i>FfxFsr2DispatchParameters</i></c> structure in order to inform FSR2\n of the jitter offset that has been applied in order to render each frame.\n\n If not using the recommended <c><i>ffxFsr2GetJitterOffset</i></c> function,\n care should be taken that your jitter sequence never generates a null vector;\n that is value of 0 in both the X and Y dimensions.\n\n @param [out] outX                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the x dimension.\n @param [out] outY                   A pointer to a <c>float</c> which will contain the subpixel jitter offset for the y dimension.\n @param [in] index                   The index within the jitter sequence.\n @param [in] phaseCount              The length of jitter phase. See <c><i>ffxFsr2GetJitterPhaseCount</i></c>.\n\n @retval\n FFX_OK                              The operation completed successfully.\n @retval\n FFX_ERROR_INVALID_POINTER           Either <c><i>outX</i></c> or <c><i>outY</i></c> was <c>NULL</c>.\n @retval\n FFX_ERROR_INVALID_ARGUMENT          Argument <c><i>phaseCount</i></c> must be greater than 0.\n\n @ingroup FSR2"]
    pub fn ffxFsr2GetJitterOffset(
        outX: *mut f32,
        outY: *mut f32,
        index: i32,
        phaseCount: i32,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " A helper function to check if a resource is\n <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @param [in] resource                A <c><i>FfxResource</i></c>.\n\n @returns\n true                                The <c><i>resource</i></c> was not <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n @returns\n false                               The <c><i>resource</i></c> was <c><i>FFX_FSR2_RESOURCE_IDENTIFIER_NULL</i></c>.\n\n @ingroup FSR2"]
    pub fn ffxFsr2ResourceIsNull(resource: FfxResource) -> bool;
}
extern "C" {
    #[doc = " Query how much memory is required for the Vulkan backend's scratch buffer.\n\n @returns\n The size (in bytes) of the required scratch memory buffer for the VK backend."]
    pub fn ffxFsr2GetScratchMemorySizeVK(physicalDevice: VkPhysicalDevice) -> usize;
}
extern "C" {
    #[doc = " Populate an interface with pointers for the VK backend.\n\n @param [out] fsr2Interface              A pointer to a <c><i>FfxFsr2Interface</i></c> structure to populate with pointers.\n @param [in] device                      A Vulkan device.\n @param [in] scratchBuffer               A pointer to a buffer of memory which can be used by the DirectX(R)12 backend.\n @param [in] scratchBufferSize           The size (in bytes) of the buffer pointed to by <c><i>scratchBuffer</i></c>.\n @param [in] physicalDevice              The Vulkan physical device that FSR 2.0 will be executed on.\n @param [in] getDeviceProcAddr           A function pointer to vkGetDeviceProcAddr which is used to obtain all the other Vulkan functions.\n\n @retval\n FFX_OK                                  The operation completed successfully.\n @retval\n FFX_ERROR_CODE_INVALID_POINTER          The <c><i>interface</i></c> pointer was <c><i>NULL</i></c>.\n\n @ingroup FSR2 VK"]
    pub fn ffxFsr2GetInterfaceVK(
        outInterface: *mut FfxFsr2Interface,
        scratchBuffer: *mut ::std::os::raw::c_void,
        scratchBufferSize: usize,
        physicalDevice: VkPhysicalDevice,
        getDeviceProcAddr: PFN_vkGetDeviceProcAddr,
    ) -> FfxErrorCode;
}
extern "C" {
    #[doc = " Create a <c><i>FfxFsr2Device</i></c> from a <c><i>VkDevice</i></c>.\n\n @param [in] device                      A pointer to the Vulkan logical device.\n\n @returns\n An abstract FidelityFX device.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetDeviceVK(device: VkDevice) -> FfxDevice;
}
extern "C" {
    #[doc = " Create a <c><i>FfxCommandList</i></c> from a <c><i>VkCommandBuffer</i></c>.\n\n @param [in] cmdBuf                      A pointer to the Vulkan command buffer.\n\n @returns\n An abstract FidelityFX command list.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetCommandListVK(cmdBuf: VkCommandBuffer) -> FfxCommandList;
}
extern "C" {
    #[doc = " Create a <c><i>FfxResource</i></c> from a <c><i>VkImage</i></c>.\n\n @param [in] context                     A pointer to a <c><i>FfxFsr2Context</i></c> structure.\n @param [in] imgVk                       A Vulkan image resource.\n @param [in] imageView                   An image view of the given image resource.\n @param [in] width                       The width of the image resource.\n @param [in] height                      The height of the image resource.\n @param [in] imgFormat                   The format of the image resource.\n @param [in] name                        (optional) A name string to identify the resource in debug mode.\n @param [in] state                       The state the resource is currently in.\n\n @returns\n An abstract FidelityFX resources.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetTextureResourceVK(
        context: *mut FfxFsr2Context,
        imgVk: VkImage,
        imageView: VkImageView,
        width: u32,
        height: u32,
        imgFormat: VkFormat,
        name: *mut u32,
        state: FfxResourceStates,
    ) -> FfxResource;
}
extern "C" {
    #[doc = " Create a <c><i>FfxResource</i></c> from a <c><i>VkBuffer</i></c>.\n\n @param [in] context                     A pointer to a <c><i>FfxFsr2Context</i></c> structure.\n @param [in] bufVk                       A Vulkan buffer resource.\n @param [in] size                        The size of the buffer resource.\n @param [in] name                        (optional) A name string to identify the resource in debug mode.\n @param [in] state                       The state the resource is currently in.\n\n @returns\n An abstract FidelityFX resources.\n\n @ingroup FSR2 VK"]
    pub fn ffxGetBufferResourceVK(
        context: *mut FfxFsr2Context,
        bufVk: VkBuffer,
        size: u32,
        name: *mut u32,
        state: FfxResourceStates,
    ) -> FfxResource;
}
